---
title: "Iteration"
author: "Gregory J. Matthews"
date: "10/12/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Vectorized Operations
```{r}
#Let's say I want the averages of a bunch of columns. 
# I COULD use a for loop.
library(Lahman)
averages <- NULL
for (i in 15:40) {
  averages[i - 14] <- mean(Teams[, i], na.rm = TRUE)
}
names(averages) <- names(Teams)[15:40]
averages

```
"It is important to understand that the fundamental architecture of R is based on vectors. That is, in contrast to general-purpose programming languages like C++ or Python that distinguish between single items—like strings and integers—and arrays of those items, in R a “string” is just a character vector of length 1. There is no special kind of atomic object. Thus, if you assign a single “string” to an object, R still stores it as a vector." - Baumer Book
```{r}
a <- "a string"
class(a)

is.vector(a)

length(a)

```

Advice: "Try to avoid writing for() loops, even when it seems like the easiest solution."


```{r}
#Instead we can use vectorized functions.
#Not all functions are vectorized!
f <- function(x){
  if (x %% 2 == 0){
    x^2
  } else {
    x^3
}
  }
  
f(1:3)
```

```{r}
#But we can make them vectorized!
f <- Vectorize(f)
f(1:3)
```


```{r}
#old school apply family.  
Teams_sub <- Teams[,unlist(lapply(Teams, is.numeric))]
round(apply(Teams_sub,2,mean, na.rm = TRUE),2)
```

```{r}
library(tidyverse)
Teams %>%
  summarize(across(where(is.numeric), mean, na.rm = TRUE))
```
## Map Family of functions
```{r}
Teams %>% 
  select(15:40) %>%
  map_dbl(mean, na.rm = TRUE) 
#Notice that na.rm is an option in the mean function!
#Note: map_dbl() forces the output to be a vector of type double.
```


```{r}
#Note that this results in an error
Teams %>% 
  select(teamID) %>% 
  map_dbl(mean, na.rm = TRUE)
```

# Iterating over a single vector

```{r}
library(Lahman)
library(tidyverse)
angels <- Teams %>% 
  filter(franchID == "ANA") %>% 
  group_by(teamID, name) %>%
  summarize(began = first(yearID), ended = last(yearID)) %>% 
  arrange(began)
angels
```

```{r}
#old school
sapply(angels$name, nchar)
```

```{r}
#nu skool
#Note I use pull and not select. 
#Pull is similar to $
angels %>% pull(name) %>% map_int(nchar)
```

```{r}
#In map_*, the * tells you what type of vector to return. 
angels %>% pull(name) %>% map_chr(nchar)
```

```{r}
#map will return a list
angels %>% pull(name) %>% map(nchar)
```
"It’s often helpful to use map() to figure out what the return type will be, and then switch to the appropriate type-specific map() variant." - Baumer Book

# iterating over our own function

```{r}
top5 <- function(data, team_name) {
  data %>%
    filter(name == team_name) %>%
    select(teamID, yearID, W, L, name) %>%
    arrange(desc(W)) %>%
    head(n = 5)
}
```

```{r}
angels_names <- angels %>%
  pull(name)
angels_names
```

```{r}
angels_names %>%
  map(top5, data = Teams)
```


```{r}
#Average number of wins for top 5 seasons
angels_names %>% 
  map_dfr(top5, data = Teams) %>%
  group_by(teamID, name) %>%
  summarize(N = n(), mean_wins = mean(W)) %>%
  arrange(desc(mean_wins))
```

#Iteration of sub groups

```{r}
hr_leader <- function(x) {
# x is a subset of Teams for a single year and league
  x %>% 
    select(teamID, HR) %>% 
    arrange(desc(HR)) %>% 
    head(1)
}

Teams %>% 
  filter(yearID == 1961 & lgID == "AL") %>% 
  hr_leader()


#.keep indicates that you want to keep the grouping variables in the output.  
hr_leaders <- Teams %>% 
  group_by(yearID, lgID) %>% 
  group_modify(~hr_leader(.x), .keep = TRUE)

tail(hr_leaders, 4)

hr_leaders %>%
  group_by(lgID) %>%
  summarize(mean_hr = mean(HR))

```

#Simulation: Coming Soon

## In class question: 
 - Using the baby names data set, find the top 100 female baby names in 1950.  Then for each name in this set, find the largest single year percentage drop for each of these names across any year from 1900 to present.  Which name has the largest single year percentage drop? 
 
 
 
 
 
 
 
 